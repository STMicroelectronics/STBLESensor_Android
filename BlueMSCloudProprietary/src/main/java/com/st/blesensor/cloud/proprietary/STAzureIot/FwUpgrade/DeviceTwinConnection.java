/*
 * Copyright (c) 2017  STMicroelectronics â€“ All rights reserved
 * The STMicroelectronics corporate logo is a trademark of STMicroelectronics
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this list of conditions
 *   and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice, this list of
 *   conditions and the following disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 *
 * - Neither the name nor trademarks of STMicroelectronics International N.V. nor any other
 *   STMicroelectronics company nor the names of its contributors may be used to endorse or
 *   promote products derived from this software without specific prior written permission.
 *
 * - All of the icons, pictures, logos and other images that are provided with the source code
 *   in a directory whose title begins with st_images may only be used for internal purposes and
 *   shall not be redistributed to any third party or modified in any way.
 *
 * - Any redistributions in binary form shall not include the capability to display any of the
 *   icons, pictures, logos and other images that are provided with the source code in a directory
 *   whose title begins with st_images.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */

package com.st.blesensor.cloud.proprietary.STAzureIot.FwUpgrade;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.google.gson.Gson;
import com.google.gson.JsonObject;

import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;

import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * class used to upload the device twin data to the cloud using the mqtt protocol
 */
public class DeviceTwinConnection {

    private static final String UPDATE_REPORTED_PROP_TOPIC = "$iothub/twin/PATCH/properties/reported/?$rid=%d";

    // reg exp to extract thr request id from the topic name
    private static final Pattern EXTRACT_RID = Pattern.compile(".*/\\?\\$rid=(\\w*)");

    //object used to create json object
    private Gson mJsonSerializer=new Gson();

    //server connection
    private IMqttAsyncClient mConnection;

    //request id generated by this class
    private int mRequestId=0;

    /**
     * generate the topic where send the reported properties
     * @return topic were send the reported properties
     */
    private String getUpdateReportedPropTopic(){
        return String.format(Locale.US,UPDATE_REPORTED_PROP_TOPIC,mRequestId++);
    }

    /**
     *
     * @param mqttConnection connection to use to upload the device info
     */
    public DeviceTwinConnection(IMqttAsyncClient mqttConnection){
        mConnection = mqttConnection;
    }

    /**
     * upload the device twin properties
     * @param device device to upload
     */
    private void updateReportedProperties(DeviceTwin device){
        Map<String,String> propSet = device.getAllReportedProperty();
        if(propSet.isEmpty())
            return;
        try {
            String deviceJson = mJsonSerializer.toJson(propSet);
            MqttMessage msg = new MqttMessage(deviceJson.getBytes());
            msg.setQos(0);
            mConnection.publish(getUpdateReportedPropTopic(),msg);
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }

    /**
     * generate a string that describe the remote method
     * @param method method to describe
     * @return string describing the method
     */
    private static String getRemoteMethodSign(RemoteMethod method){
        StringBuilder sb = new StringBuilder();
        sb.append(method.getName());
        List<RemoteMethod.Param> params = method.getParams();
        if(!params.isEmpty()) {
            sb.append('-');
            for (RemoteMethod.Param p : params) {
                sb.append("-");
                sb.append(p.name);
                sb.append("-");
                sb.append(p.type);
            }
        }
        return sb.toString();
    }

    /**
     * upload the remote methods supported by the specific device twin
     * @param device to upload
     */
    private void updateRemoteMethods(DeviceTwin device){
        Collection<RemoteMethod> remoteMethods = device.getRemoteMethods();
        if(remoteMethods.isEmpty())
            return;

        JsonObject obj = new JsonObject();
        obj.add("SupportedMethods",getRemoteMethods(remoteMethods));
        try {
            MqttMessage msg = new MqttMessage(obj.toString().getBytes());
            msg.setQos(0);
            mConnection.publish(getUpdateReportedPropTopic(),msg);
        } catch (MqttException e) {
            e.printStackTrace();
        }

    }

    /**
     * upload the device values into the cloud
     * @param device device to upload
     */
    public void updateRemoteTwin(DeviceTwin device){
        updateReportedProperties(device);
        updateRemoteMethods(device);
    }

    /**
     * crate a json object containing all the remote methods description
     * @param methods method to add to the object
     * @return json object containing all the method description
     */
    private static @NonNull JsonObject getRemoteMethods(Collection<RemoteMethod> methods){
        JsonObject obj = new JsonObject();

        for (RemoteMethod m : methods) {
            obj.addProperty(getRemoteMethodSign(m),m.getDescription());
        }
        return obj;
    }

    /**
     * generate the topic where the cloud will notify a call to the remote method
     * @param method method to listen
     * @return topic where listen to method call
     */
    private static String getMethodTopic(RemoteMethod method){
        return "$iothub/methods/POST/"+method.getName()+"/#";
    }

    /**
     * extract the request id from a topic name
     * @param topic topic containing the request id
     * @return if present the request id (hex number) otherwise null
     */
    private static @Nullable String extractRequestId(CharSequence topic){
        Matcher ridMatch = EXTRACT_RID.matcher(topic);
        if(ridMatch.find())
            return ridMatch.group(1);
        return null;
    }

    /**
     * register a callback for remote methods called to a specific device
     * @param device remote call target device
     * @param callback object to call when a remote call is done
     */
    public void onRemoteMethodCall(DeviceTwin device, final RemoteMethodInvocation callback) {

        for(final RemoteMethod method : device.getRemoteMethods()){
            try {
                mConnection.subscribe(getMethodTopic(method), 0, method, null, new IMqttMessageListener() {
                    @Override
                    public void messageArrived(String topic, MqttMessage message) throws Exception {
                        String rid = extractRequestId(topic);
                        if(rid == null) //not a valid request
                            return;
                        String jsonContent = message!=null ? new String(message.getPayload()) : "";
                        JsonObject functionParam = mJsonSerializer.fromJson(jsonContent,JsonObject.class);
                        callback.invoke(method,functionParam);
                        //200 = call is ok
                        mConnection.publish("$iothub/methods/res/200/?$rid="+rid, new MqttMessage());
                    }
                });
            } catch (MqttException e) {
                e.printStackTrace();
            }//try-catch
        }//for remote method
    }//onRemoteMethodCall

    /**
     * interface used to notify a remote invocation
     */
    public interface RemoteMethodInvocation{

        /**
         * callback done when a remote method is called
         * @param method method invoked
         * @param parm json object contains the method parameters
         */
        void invoke(RemoteMethod method, JsonObject parm);
    }
}
